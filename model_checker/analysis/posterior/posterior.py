"""
Posterior predictive distribution sampling.

Generalized to work with any UMLI model and flexible output shapes
(scalar, 1D vector, or N-dimensional arrays).
"""

from typing import Callable, List, Optional, Type

import numpy as np

from model_checker.umli.data.unified_dataset import UnifiedDataset
from model_checker.umli.model.unified_model import UnifiedModel


def _ensure_2d_input(X: np.ndarray) -> np.ndarray:
    """
    Ensure input X is 2D for consistent processing.

    Args:
        X: Input array (can be scalar, 1D, or 2D)

    Returns:
        2D array of shape (n_samples, n_features)
    """
    X = np.asarray(X)
    if X.ndim == 0:
        X = X.reshape(1, 1)
    elif X.ndim == 1:
        X = X.reshape(1, -1)
    return X


def _normalize_output_shape(predictions: np.ndarray) -> np.ndarray:
    """
    Normalize prediction output to consistent shape for stacking.

    Handles scalar, 1D, and N-dimensional outputs.

    Args:
        predictions: Prediction array of any shape

    Returns:
        Flattened array for consistent stacking
    """
    predictions = np.asarray(predictions)
    return predictions.flatten()


def sample_posterior_predictive(
    trained_models: List[UnifiedModel],
    X: np.ndarray,
    noise_fn: Optional[Callable[[np.ndarray], np.ndarray]] = None,
) -> np.ndarray:
    """
    Make predictions with noise for each trained bootstrap model.

    For each i-th trained model, makes predictions on X with optionally added noise:
    y_i = f_i(X) + epsilon, where epsilon is generated by the noise function.

    Supports flexible output shapes: scalar, 1D vector, or N-dimensional arrays.

    Args:
        trained_models: List of trained UnifiedModel instances from bootstrap training
        X: Input features to make predictions on (can be scalar, 1D, or 2D)
        noise_fn: Optional callable that takes a prediction array and returns noise
                 of compatible shape. If None, no noise is added (deterministic predictions).
                 If provided, noise is added to predictions.

    Returns:
        Array of shape (n_bootstrap, *output_shape) containing predictions
        for each bootstrap model. Output shape is determined by model predictions.

    Raises:
        ValueError: If noise shape is incompatible with prediction shape.
    """
    X = _ensure_2d_input(X)
    predictions = []

    # Make predictions with each trained model
    for model in trained_models:
        # Make predictions
        y_pred = model.predict(X)

        # Add noise if noise function is provided
        if noise_fn is not None:
            # Generate noise using the provided function
            noise = noise_fn(y_pred)

            # Validate noise shape compatibility
            if noise.shape != y_pred.shape:
                raise ValueError(
                    f"Noise shape {noise.shape} is incompatible with prediction "
                    f"shape {y_pred.shape}. Noise function must return noise "
                    "with the same shape as the input prediction."
                )

            y_pred_noise = y_pred + noise
        else:
            y_pred_noise = y_pred

        predictions.append(y_pred_noise)

    # Stack predictions
    # Handle flexible output shapes
    try:
        # Try to stack directly
        stacked = np.stack(predictions, axis=0)
    except ValueError:
        # If shapes don't match, flatten each prediction and stack
        # This handles cases where outputs have different shapes
        flattened = [_normalize_output_shape(p) for p in predictions]
        stacked = np.array(flattened)

    return stacked


def approximate_posterior_predictive(
    model_type: Type[UnifiedModel],
    dataset: UnifiedDataset,
    X: np.ndarray,
    n_bootstrap: int = 100,
    config: Optional[dict] = None,
    noise_fn: Optional[Callable[[np.ndarray], np.ndarray]] = None,
    rng: Optional[np.random.Generator] = None,
) -> np.ndarray:
    """
    Complete pipeline: bootstrap training + posterior predictive sampling.

    This function combines bootstrap training and posterior predictive sampling
    to approximate the posterior predictive distribution.

    Works with any UMLI model and supports flexible output shapes.

    Args:
        model_type: Type/class of UnifiedModel to instantiate and train
        dataset: Training UnifiedDataset
        X: Input features to make predictions on (can be scalar, 1D, or 2D)
        n_bootstrap: Number of bootstrap iterations
        config: Optional configuration dictionary for model hyperparameters.
                If None, model_type must be instantiable with no arguments.
        noise_fn: Optional callable that takes a prediction array and returns noise
                 of compatible shape. If None, no noise is added (deterministic predictions).
                 If provided, noise is added to predictions.
        rng: Optional random number generator for reproducibility (used for bootstrap)

    Returns:
        Array of shape (n_bootstrap, *output_shape) containing predictions
        for each bootstrap model. Output shape matches model prediction shape.

    Raises:
        ValueError: If noise shape is incompatible with prediction shape.
    """
    from model_checker.analysis.posterior.bootstrap import bootstrap_train_models

    if rng is None:
        rng = np.random.default_rng()

    # Step 1: Bootstrap training - returns list of trained models
    trained_models = bootstrap_train_models(
        model_type, dataset, n_bootstrap, config, rng
    )

    # Step 2: Sample posterior predictive using trained models
    predictions = sample_posterior_predictive(trained_models, X, noise_fn)

    return predictions
